diff --git a/src/AsyncEvent.php b/src/AsyncEvent.php
index b114e57..b7ef7ac 100644
--- a/src/AsyncEvent.php
+++ b/src/AsyncEvent.php
@@ -4,7 +4,7 @@ namespace Cache;

 use Cache\Interface\KeyInterface;

-class InvalidationEvent extends \stdClass
+class AsyncEvent
 {
     public function __construct(
         public KeyInterface $key,
diff --git a/src/AsyncHandler.php b/src/AsyncHandler.php
index 3339785..3759d2f 100644
--- a/src/AsyncHandler.php
+++ b/src/AsyncHandler.php
@@ -8,10 +8,10 @@ class AsyncHandler {
         private Cache $cache,
     ) {}

-    public function handleInvalidation(InvalidationEvent $event): void
+    public function handleInvalidation(AsyncEvent $event): void
     {
-        $key = $event['key'];
-        $exact = $event['exact'];
+        $key = $event->key;
+        $exact = $event->exact;

         if ($exact) {
             $this->cache->invalidateExact($key, SyncMode::SYNC);
@@ -20,9 +20,9 @@ class AsyncHandler {
         }
     }

-    public function handleRefresh(InvalidationEvent $event): void
+    public function handleRefresh(AsyncEvent $event): void
     {
-        $key = $event['key'];
+        $key = $event->key;

         $this->cache->refresh($key, SyncMode::SYNC);
     }
diff --git a/src/Cache.php b/src/Cache.php
index 8ef47ec..0efe3b3 100644
--- a/src/Cache.php
+++ b/src/Cache.php
@@ -18,14 +18,13 @@ use Stash\Invalidation;
 class Cache implements CacheInterface, PsrPoolAccessInterface
 {
     public function __construct(
-        private StashPoolInterface        $pool,
-        private LoaderInterface           $loader,
-        private int                       $hardTtlSec,
-        private int                       $precomputeSec,         // seconds BEFORE hard TTL to precompute (soft window)
-        private JitterInterface           $jitter,
-        private EventDispatcherInterface|null  $eventDispatcher = null,
+        private StashPoolInterface            $pool,
+        private LoaderInterface               $loader,
+        private int                           $hardTtlSec,
+        private int                           $precomputeSec,         // seconds BEFORE hard TTL to precompute (soft window)
+        private JitterInterface               $jitter,
+        private EventDispatcherInterface|null $eventDispatcher = null,
         private MetricsInterface|null         $metrics = null,
-        private \Psr\Log\LoggerInterface|null $logger = null,
     )
     {
         if ($hardTtlSec < 1) throw new \InvalidArgumentException('hardTtlSec must be >= 1');
@@ -38,41 +37,83 @@ class Cache implements CacheInterface, PsrPoolAccessInterface
     {
         $item = $this->pool->getItem($key->toString());

-        // 1) precompute: start regeneration pre-expiry; isHit() becomes false inside the soft window
-        $item->setInvalidationMethod(Invalidation::PRECOMPUTE, $this->precomputeSec);
-
-        $value = $item->get();
-        if ($item->isHit()) {
-            [$createdAt, $softAt] = $this->timestampsFromItem($item);
-            $this->metrics?->inc('cache_hit', ['state' => 'fresh']);
-            return ValueResult::hit($value, $createdAt, $softAt);
+        // 1) fast path: fresh hit
+        if ($result = $this->tryFreshHit($item)) {
+            return $result;
         }

-        // 2) single-flight: try to become the leader
+        // 2) single-flight: become the leader and recompute
         $won = $item->lock();
         if ($won) {
             try {
-                $loaded = $this->loader->resolve($key);
-                $this->save($key, $loaded); // sets hard TTL (with jitter) and stores value
-                $this->metrics?->inc('cache_fill');
-
-                // recompute times deterministically after save
-                $now = time();
-                $hard = $now + $this->hardTtlSec;
-                $soft = $hard - $this->precomputeSec;
-                if ($soft < $now) {
-                    $soft = $now;
-                }
-
-                return ValueResult::hit($loaded, $now, $soft);
+                return $this->leaderComputeAndSave($key);
             } finally {
                 // lock is released when $item is out of scope (Stash frees it with Item lifecycle)
                 unset($item);
             }
         }

-        // 3) follower path: someone else is rebuilding â€” serve stale or briefly wait
-        // a) try to serve STALE while leader holds the lock
+        // 3) follower path: serve stale
+        if ($result = $this->tryFollowerServeStale($key)) {
+            return $result;
+        }
+
+        // 4) follower path: wait for leader to finish
+        if ($result = $this->tryFollowerWaitFresh($key)) {
+            return $result;
+        }
+
+        // 5) last resort: fail-open compute or miss
+        return $this->failOpenOrMiss($key);
+    }
+
+    /** Extract createdAt and soft boundary from Stash item. */
+    private function timestampsFromItem(ItemInterface $item): array
+    {
+        $createdAt = $item->getCreation() ? $item->getCreation()->getTimestamp() : time();
+        $expiresAt = $item->getExpiration() ? $item->getExpiration()->getTimestamp() : ($createdAt + $this->hardTtlSec);
+        $softAt = $expiresAt - $this->precomputeSec;
+        if ($softAt < $createdAt) {
+            $softAt = $createdAt;
+        }
+        return [$createdAt, $softAt];
+    }
+
+    /** Try to return a fresh hit if available. Returns null on miss. */
+    private function tryFreshHit(ItemInterface $item): ?ValueResultInterface
+    {
+        $item->setInvalidationMethod(Invalidation::PRECOMPUTE, $this->precomputeSec);
+        $value = $item->get();
+        if ($item->isHit()) {
+            [$createdAt, $softAt] = $this->timestampsFromItem($item);
+            $this->metrics?->inc('cache_hit', ['state' => 'fresh']);
+            return ValueResult::hit($value, $createdAt, $softAt);
+        }
+        return null;
+    }
+
+    /** Leader path: compute and save, returning a fresh hit result. */
+    private function leaderComputeAndSave(KeyInterface $key): ValueResultInterface
+    {
+        $loaded = $this->loader->resolve($key);
+        $this->save($key, $loaded); // sets hard TTL (with jitter) and stores value
+        $this->metrics?->inc('cache_fill');
+
+        // recompute times deterministically after save
+        $now = time();
+        $hard = $now + $this->hardTtlSec;
+        $soft = $hard - $this->precomputeSec;
+        if ($soft < $now) {
+            $soft = $now;
+        }
+
+        return ValueResult::hit($loaded, $now, $soft);
+    }
+
+    /** Follower: try to serve stale value while leader holds the lock. */
+    private function tryFollowerServeStale(KeyInterface $key): ?ValueResultInterface
+    {
+        $item = $this->pool->getItem($key->toString());
         $item->setInvalidationMethod(Invalidation::OLD); // serve previous value if locked by another process
         $stale = $item->get();
         if ($stale !== null) {
@@ -80,8 +121,13 @@ class Cache implements CacheInterface, PsrPoolAccessInterface
             $this->metrics?->inc('cache_hit', ['state' => 'stale']);
             return ValueResult::stale($stale, $createdAt, $softAt);
         }
+        return null;
+    }

-        // b) optional: short wait for leader to finish (CLI/background-safe)
+    /** Follower: short wait for leader to finish, then try to return fresh. */
+    private function tryFollowerWaitFresh(KeyInterface $key): ?ValueResultInterface
+    {
+        $item = $this->pool->getItem($key->toString());
         $item->setInvalidationMethod(Invalidation::SLEEP, 150, 6); // 6x150ms = ~900ms max wait
         $waited = $item->get();
         if ($item->isHit()) {
@@ -89,8 +135,12 @@ class Cache implements CacheInterface, PsrPoolAccessInterface
             $this->metrics?->inc('cache_hit', ['state' => 'fresh_after_sleep']);
             return ValueResult::hit($waited, $createdAt, $softAt);
         }
+        return null;
+    }

-        // c) last resort: fail-open compute (do NOT save to avoid double-write), or miss if you prefer fail-closed
+    /** Last resort: compute fail-open (do not save) or return miss if fail-closed. */
+    private function failOpenOrMiss(KeyInterface $key): ValueResultInterface
+    {
         if ($this->failOpen ?? true) {
             $fallback = $this->loader->resolve($key);
             $now = time();
@@ -104,18 +154,6 @@ class Cache implements CacheInterface, PsrPoolAccessInterface
         return ValueResult::miss();
     }

-    /** Extract createdAt and soft boundary from Stash item. */
-    private function timestampsFromItem(ItemInterface $item): array
-    {
-        $createdAt = $item->getCreation() ? $item->getCreation()->getTimestamp() : time();
-        $expiresAt = $item->getExpiration() ? $item->getExpiration()->getTimestamp() : ($createdAt + $this->hardTtlSec);
-        $softAt = $expiresAt - $this->precomputeSec;
-        if ($softAt < $createdAt) {
-            $softAt = $createdAt;
-        }
-        return [$createdAt, $softAt];
-    }
-
     public function getMany(iterable $keys): \SplObjectStorage
     {
         // naive: iterate; real impl may group and use resolveMany()
@@ -132,11 +170,23 @@ class Cache implements CacheInterface, PsrPoolAccessInterface
         $this->metrics?->inc('cache_put');
     }

+    private function save(KeyInterface $key, mixed $value): void
+    {
+        $item = $this->pool->getItem($key->toString());
+        // Stash TTL is hard TTL; add jitter if configured
+        $hardTtl = $this->jitter?->apply($this->hardTtlSec, $key) ?? $this->hardTtlSec;
+
+        // PSR-6: store raw value; Stash keeps creation/expiration internally
+        $item->set($value);
+        $item->expiresAfter($hardTtl);
+        $this->pool->save($item);
+    }
+
     public function invalidate(KeyPrefixInterface|KeyInterface|array $selectors, SyncMode $mode = SyncMode::ASYNC): void
     {
         foreach ((array)$selectors as $selector) {
             if ($mode === SyncMode::ASYNC) {
-                $this->eventDispatcher->dispatch(new InvalidationEvent($selector, $mode, false));
+                $this->eventDispatcher->dispatch(new AsyncEvent($selector, false));
                 return;
             }

@@ -149,7 +199,7 @@ class Cache implements CacheInterface, PsrPoolAccessInterface
     {
         foreach ((array)$keys as $key) {
             if ($mode === SyncMode::ASYNC) {
-                $this->eventDispatcher->dispatch(new InvalidationEvent($key, $mode, true));
+                $this->eventDispatcher->dispatch(new AsyncEvent($key, true));
                 return;
             }

@@ -162,7 +212,7 @@ class Cache implements CacheInterface, PsrPoolAccessInterface
     {
         foreach ((array)$keys as $key) {
             if ($mode === SyncMode::ASYNC) {
-                $this->eventDispatcher->dispatch(new InvalidationEvent($key, $mode, true));
+                $this->eventDispatcher->dispatch(new AsyncEvent($key));
                 return;
             }

@@ -174,16 +224,4 @@ class Cache implements CacheInterface, PsrPoolAccessInterface
     {
         return $this->pool;
     }
-
-    private function save(KeyInterface $key, mixed $value): void
-    {
-        $item = $this->pool->getItem($key->toString());
-        // Stash TTL is hard TTL; add jitter if configured
-        $hardTtl = $this->jitter?->apply($this->hardTtlSec, $key) ?? $this->hardTtlSec;
-
-        // PSR-6: store raw value; Stash keeps creation/expiration internally
-        $item->set($value);
-        $item->expiresAfter($hardTtl);
-        $this->pool->save($item);
-    }
 }
